#!/usr/bin/env python
import numpy as np

class FK():

    def __init__(self):
        # Define geometric parameters for computing the forward kinematics. 
        # The required parameters are provided in the assignment description document.
        self.dh_params = self.init_dh_params()
        self.joint_offsets = self.init_joint_offsets()

    def init_dh_params(self):
        """
        Initialize dh parameters from all intermediate frames in the form [a, alpha, d]
        (refer to assignment description)
        """

        dh_params = [
        [ 0.000, -np.pi/2, 0.333], # Joint 1
        [ 0.000,  np.pi/2, 0.000], # Joint 2
        [ 0.082,  np.pi/2, 0.316], # Joint 2
        [-0.082, -np.pi/2, 0.000], # Joint 2
        [ 0.000,  np.pi/2, 0.384], # Joint 2
        [ 0.088,  np.pi/2, 0.000], # Joint 2
        [ 0.000,  0.0    , 0.210], # Joint 2
]
        return dh_params

    def init_joint_offsets(self):
        """
        Initialize joint position offsets
        relative to intermediate frames defined using
        DH conventions 
        (refer to assignment description)
        """

        joint_offsets = [
            [0, 0, 0.141],
            [0, 0, 0.000],
            [0, 0, 0.195],
            [0, 0, 0.000],
            [0, 0, 0.125],
            [0, 0, 0.000],
            [0, 0, 0.051],
        ]
        return joint_offsets

    def build_dh_transform(self, a, alpha, d, theta):
        """
        Construct transformation matrix T,
        using DH parameters and conventions
        """
        
        T = []
        # YOUR CODE STARTS HERE
        c_theta = np.cos(theta)
        s_theta = np.sin(theta)
        c_alpha = np.cos(alpha)
        s_alpha = np.sin(alpha)

        T = np.array([
            [c_theta, -s_theta * c_alpha, s_theta * s_alpha, a * c_theta],
            [s_theta,  c_theta * c_alpha,-c_theta * s_alpha, a * s_theta],
            [    0.0,            s_alpha,           c_alpha,           d],
            [    0.0,                0.0,               0.0,         1.0],
        ])
        # YOUR CODE ENDS HERE
        return T

    def forward(self, q):
        """
        INPUT:
        q - 1x7 vector of joint angles [q0, q1, q2, q3, q4, q5, q6]

        OUTPUTS:
        jointPositions - 7 x 3 matrix, where each row corresponds to a rotational joint of the robot
                         Each row contains the [x,y,z] coordinates in the world frame of the respective 
                         joint's center in meters. The base of the robot is located at [0,0,0].

        T0e - a homogeneous transformation matrix,
              representing the end effector frame expressed in the world frame
        """

        jointPositions = []
        T0e = []
        # YOUR CODE STARTS HERE
        # Initialize an empty 7x3 numpy array for joint positions and an identity matrix for T0e
        jointPositions = np.zeros((7, 3))
        T0e = np.eye(4)
        
        # Iterate through all 7 joints to compute transformations and positions
        for i in range(7):
            # Extract current DH parameters and joint angle
            a, alpha, d = self.dh_params[i]
            theta = q[i]
            
            # 1. Compute DH transformation matrix for current joint
            T_i = self.build_dh_transform(a, alpha, d, theta)
            
            # 2. Update global transformation matrix (multiply from the right)
            T0e = np.matmul(T0e, T_i)
            
            # 3. Calculate actual physical joint center position using the provided offset
            # Convert offset to homogeneous coordinates [x, y, z, 1]
            offset_x, offset_y, offset_z = self.joint_offsets[i]
            offset_homo = np.array([offset_x, offset_y, offset_z, 1.0])
            
            # Transform the local offset to world frame
            pos_world = np.matmul(T0e, offset_homo)
            
            # 4. Save the [x, y, z] coordinates to the output matrix
            jointPositions[i, :] = pos_world[0:3]

        # YOUR CODE ENDS HERE
        T0e = np.matmul(T0e, self.build_dh_transform(0, 0, 0, -np.pi/4))
        return jointPositions, T0e

if __name__ == "__main__":
    pass
