#!/usr/bin/env python
import os
import sys
import numpy as np
from solution.solveFK import FK

class IK:

    # JOINT LIMITS
    lower = np.array([-2.8973,-1.7628,-2.8973,-3.0718,-2.8973,-0.0175,-2.8973])
    upper = np.array([2.8973,1.7628,2.8973,-0.0698,2.8973,3.7525,2.8973])

    fk = FK()

    def __init__(self):
        pass

    @staticmethod
    def calcJacobian(q):
        """
        Calculate the Jacobian of the end effector in a given configuration.
        INPUT:
        q - 1 x 7 vector of joint angles [q0, q1, q2, q3, q4, q5, q6]
        OUTPUT:
        J - the Jacobian matrix 
        """

        J = []       
        # YOUR CODE STARTS HERE

        J = np.zeros((6, 7))
        T = np.eye(4)
        z_axes = []
        positions = []
        
        # Calculate intermediate transformations to find the Z-axis and position of each joint
        for i in range(7):
            z_axes.append(T[0:3, 2])
            positions.append(T[0:3, 3])
            
            a, alpha, d = IK.fk.dh_params[i]
            T_i = IK.fk.build_dh_transform(a, alpha, d, q[i])
            T = np.matmul(T, T_i)
            
        # The final end-effector fixed transformation
        T_ee = np.matmul(T, IK.fk.build_dh_transform(0, 0, 0, -np.pi/4))
        p_ee = T_ee[0:3, 3]
        
        # Construct the 6x7 Jacobian matrix
        for i in range(7):
            z = z_axes[i]
            p = positions[i]
            J[0:3, i] = np.cross(z, p_ee - p) # Linear velocity part
            J[3:6, i] = z                     # Angular velocity part

        # YOUR CODE ENDS HERE
        return J

    @staticmethod
    def cal_target_transform_vec(target, current):
        """
        Calculate the displacement vector and axis of rotation from 
        the current frame to the target frame

        INPUTS:
        target - 4x4 numpy array representing the desired transformation from
                 end effector to world

        current - 4x4 numpy array representing the current transformation from
                  end effector to world

        OUTPUTS:
        translate_vec - a 3-element numpy array containing the target translation vector from
                        the current frame to the target frame, expressed in the world frame

        rotate_vec - a 3-element numpy array containing the target rotation vector from
                     the current frame to the end effector frame
        """

        translate_vec = []
        rotate_vec = []
        # YOUR CODE STARTS HERE

        # Translation error
        translate_vec = target[0:3, 3] - current[0:3, 3]
        
        # Rotation error based on Axis-Angle representation
        R_target = target[0:3, 0:3]
        R_curr = current[0:3, 0:3]
        R_err = np.matmul(R_target, R_curr.T)
        
        # Calculate the angle of rotation, clipping to avoid math domain errors
        angle = np.arccos(np.clip((np.trace(R_err) - 1.0) / 2.0, -1.0, 1.0))
        
        # Handle singularity when the angle is exactly 0
        if np.isclose(angle, 0.0):
            rotate_vec = np.zeros(3)
        else:
            rx = R_err[2, 1] - R_err[1, 2]
            ry = R_err[0, 2] - R_err[2, 0]
            rz = R_err[1, 0] - R_err[0, 1]
            r = np.array([rx, ry, rz])
            rotate_vec = (angle / (2.0 * np.sin(angle))) * r

        ## YOUR CODE ENDS HERE

        return translate_vec, rotate_vec

    def check_joint_constraints(self,q,target):
        """
        Check if the given candidate solution respects the joint limits.

        INPUTS
        q - the given solution (joint angles)

        target - 4x4 numpy array representing the desired transformation from
                 end effector to world

        OUTPUTS:
        success - True if some predefined certain conditions are met. Otherwise False
        """

        success = False

        # YOUR CODE STARTS HERE

        # Check Condition 1: Joint Limits
        within_limits = np.all(q >= self.lower) and np.all(q <= self.upper)
        
        # Check Condition 2: Target reachability (Tolerance check)
        _, T0e = self.fk.forward(q)
        trans_err, rot_err = self.cal_target_transform_vec(target, T0e)
        error_norm = np.linalg.norm(trans_err) + np.linalg.norm(rot_err)
        
        # Success as being within limits AND having an error smaller than 1e-2
        success = within_limits and (error_norm < 1e-2)

        # YOUR CODE ENDS HERE

        return success


    @staticmethod
    def solve_ik(q,target):
        """
        Uses the method you prefer to calculate the joint velocity 

        INPUTS:
        q - the current joint configuration, a "best guess" so far for the final solution

        target - a 4x4 numpy array containing the target end effector pose

        OUTPUTS:
        dq - a desired joint velocity
        Note: Make sure that it will smoothly decay to zero magnitude as the task is achieved.
        """

        dq = []
        # YOUR CODE STARTS HERE
        _, current_T = IK.fk.forward(q)
        trans_err, rot_err = IK.cal_target_transform_vec(target, current_T)
        
        # Combine translation and rotation errors into a 6x1 vector
        e = np.concatenate((trans_err, rot_err))
        
        J = IK.calcJacobian(q)
        
        # Jacobian Transpose Method implementation
        # dq = gain * (J^T * e)
        # The gain acts as an adaptive step size. Setting it to increase stability.
        gain = 0.1
        dq = gain * np.matmul(J.T, e)
        # YOUR CODE ENDS HERE

        return dq

    def inverse(self, target, initial_guess):
        """
        Solve the inverse kinematics of the robot arm

        INPUTS:
        target - 4x4 numpy array representing the desired transformation from
        end effector to world

        initial_guess - 1x7 vector of joint angles [q0, q1, q2, q3, q4, q5, q6], which
        is the "initial guess" from which to proceed with the solution process (has set up for you)

        OUTPUTS:
        q - 1x7 vector of joint angles [q0, q1, q2, q3, q4, q5, q6], giving the
        solution if success is True or the closest guess if success is False.

        success - True if IK is successfully solved. Otherwise False
        """

        q = initial_guess
        success = False

        # YOUR CODE STARTS HERE

        max_iterations = 5000
        tolerance = 1e-3
        q = np.copy(initial_guess)
        
        print("\n[INFO] Starting IK solver, please wait...")
        
        for i in range(max_iterations):
            # 1. Get desired joint velocity from Jacobian Transpose
            dq = self.solve_ik(q, target)
            
            error_norm = np.linalg.norm(dq)
            
            # Print progress every 500 iterations so we know it's not frozen
            if i % 500 == 0:
                print(f"      -> Iteration {i}, current error norm: {error_norm:.6f}")
            
            # 2. Check terminating condition
            if error_norm < tolerance:
                print(f"[SUCCESS] Successfully Total iterations: {i}")
                break
                
            # 3. Update current joint configuration
            q = q + dq
            
            # 4. Enforce joint limits strictly at each step
            q = np.clip(q, self.lower, self.upper)
            
        success = self.check_joint_constraints(q, target)
        if not success:
            print("[WARNING] Reached maximum iterations (5000). Might not have converged perfectly.")

        # YOUR CODE ENDS HERE

        return q, success
